// Copyright 2020 Team slow. All right reserved.

#pragma once

#include "Common/Index2D.h"

#include "SokobanGameActor.generated.h"

class USokobanGameSlot;
class UStaticMesh;
class USokobanGameItem;
class UBoxComponent;
class UGoalIndicatorComponent;

UCLASS()
class SLOW_API ASokobanGameActor : public AActor
{
	GENERATED_BODY()

private:
	enum ConsumeFlags
	{
		CF_Succeeded = 0,
		CF_Countdown = 1,
	};

	enum Tasks
	{
		Task_Destruct,
		Task_DestructAll,
		Task_Retry,
		Task_Succeeded,
	};

private:
	uint8 bRefreshed : 1;
	uint8 bSucceeded : 1;

	/** 전체 슬롯 X축 개수를 나타냅니다. */
	UPROPERTY(EditAnywhere, Category = "Game", meta = (AllowPrivateAccess = "true"))
	int32 ItemCountX;
	/** 전체 슬롯 Y축 개수를 나타냅니다. */
	UPROPERTY(EditAnywhere, Category = "Game", meta = (AllowPrivateAccess = "true"))
	int32 ItemCountY;
	/** 목적 슬롯의 인덱스를 나타냅니다. */
	UPROPERTY(EditAnywhere, Category = "Game", meta = (AllowPrivateAccess = "true"))
	TArray<FIndex2D> GoalIndexes;
	/** 행동 카운트를 나타냅니다. */
	UPROPERTY(EditAnywhere, Category = "Game", meta = (AllowPrivateAccess = "true"))
	int32 MaxActionCount;
	/** 퍼즐을 완료할 경우 이동할 서브레벨 그룹 이름을 나타냅니다. */
	UPROPERTY(EditAnywhere, Category = "Game", meta = (AllowPrivateAccess = "true"))
	FName SublevelGroupTableName;

	UPROPERTY(VisibleAnywhere, meta = (AllowPrivateAccess = "true"))
	UBoxComponent* Root;
	UPROPERTY()
	TArray<USokobanGameSlot*> SlotComponents;
	UPROPERTY()
	TArray<USokobanGameItem*> ItemComponents;

	UPROPERTY(EditAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	UStaticMesh* SlotMesh;
	UPROPERTY(EditAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	float CellWidth;
	UPROPERTY(EditAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	float CellHeight;
	UPROPERTY(EditAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	FVector SlotMeshScale;
	UPROPERTY(VisibleAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	TArray<USceneComponent*> GoalIndicators;
	/** 목적지 표시 클래스를 설정합니다. */
	UPROPERTY(EditAnywhere, Category = "Appearance", meta = (AllowPrivateAccess = "true"))
	TSubclassOf<UGoalIndicatorComponent> GoalIndicatorClass;

#if WITH_EDITOR
	/** 자동 생성에 사용할 아이템 클래스를 설정합니다. */
	UPROPERTY(EditAnywhere, Category = "Auto Generation", meta = (AllowPrivateAccess = "true"))
	TArray<TSubclassOf<USokobanGameItem>> ItemClass;
	/** 파싱 텍스트를 설정합니다. */
	UPROPERTY(EditAnywhere, Category = "Auto Generation", meta = (AllowPrivateAccess = "true"))
	FString AutoGenerationText;
	/** 자동 생성을 이용해 만들어진 컴포넌트의 목록입니다. */
	UPROPERTY(VisibleAnywhere, Category = "Auto Generation", meta = (AllowPrivateAccess = "true"))
	TArray<USokobanGameItem*> AutoGeneratedComponents;
#endif

	int32 RemainActionCount;
	TQueue<Tasks> TaskQueue;

public:
	ASokobanGameActor();

	void BeginPlay() override;
	void EndPlay(const EEndPlayReason::Type InEndPlayReason) override;
	void Tick(float InDeltaSeconds) override;

#if WITH_EDITOR
	void PostEditChangeProperty(FPropertyChangedEvent& InEvent) override;
#endif

	bool MoveSlotItem(USokobanGameItem* InItem, int32 DestX, int32 DestY, bool bForceRetry = false);
	FVector2D QuerySlotLocation(int32 X, int32 Y) const;
	bool CheckIndexMovable(int32 X, int32 Y) const;
	ConsumeFlags ConsumeMove();

	void Destruct();
	void DestructAll();
	void Retry();
	void Succeeded();

	/** 프로퍼티가 제대로 바인드 되어 있지 않을 때, 다시 설정합니다. */
	UFUNCTION(CallInEditor)
	void Refresh();

#if WITH_EDITOR
	/** 파싱 텍스트 프로퍼티와 클래스 프로퍼티를 사용하여 컴포넌트를 자동 생성합니다. 자동 생성된 컴포넌트는 에디터에서 참조할 수 없을 수 있습니다. */
	UFUNCTION(CallInEditor, Category = "Auto Generation")
	void CreateAuto();
	/** 자동 생성으로 만들어진 모든 컴포넌트를 제거합니다. */
	UFUNCTION(CallInEditor, Category = "Auto Generation")
	void RemoveAllAutoGenerationComponents();
	/** 프로퍼티의 더티 상태를 초기화합니다. */
	UFUNCTION(CallInEditor, Category = "Auto Generation")
	void Cleanup();
#endif

private:
	void OnPropertyChanged_ItemCount();
	void OnPropertyChanged_SlotMesh();
	void OnPropertyChanged_SlotMeshScale();
	void OnPropertyChanged_CellSize();
	void RefreshSlotItemProperty(int32 X, int32 Y) const;

	USokobanGameSlot* NewCellComponent(int32 InX, int32 InY);

	USokobanGameSlot*& GetCell(int32 InX, int32 InY);
	USokobanGameSlot* const& GetCell(int32 InX, int32 InY) const;
	TTuple<int32, int32> Break(int32 Number) const;

	void ResolveTask();
	void RefreshRootExtent();
	void RefreshSlotReferences();
	bool CheckGoals() const;
};